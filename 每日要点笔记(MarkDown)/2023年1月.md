# 1月4日：

### 1.关于.msi文件

msi是微软的程序安装文件

msi是Windows installer开发出来的程序安装文件，它可以让你安装，修改，卸载你所安装的程序。说白了，.msi相当于是一个数据包，把所有和安装文件相关的内容封装在一个包里。

### 2.微信默认的截图文件路径

```sh
C:\Users\21681\Documents\WeChat Files\wxid_niz037025uq222\FileStorage\Cache
```

# 1月5日：

### 1.关于super（）

构造方法的第一行永远默认是父类的构造方法super（）

手动给成员变量赋值的时机一定是在调用父类构造方法中的super之后

# 1月6日：

### 1.支付宝开放平台官网：

https://open.alipay.com/

### 2.instanceOf关键字

a instanceOf A:判断对象a是否是类A的实例。如果是，返回true,如果不是，返回false.

**使用场景：**
为了避免在向下转型时出现类转换异常，我们在向下转型之前，先进行instanceof的判断，一旦返回true,就进行向下转型。如果返回false,不进行向下转型。

例：

```java
@Override
public BrandStandardVO get(Long id) {
    Serializable serializable = redisTemplate.opsForValue().get(BRAND_ITEM_KEY_PREFIX+id);
    BrandStandardVO brandStandardVO = null;
    if (serializable!=null){
        if (serializable instanceof BrandStandardVO){
            brandStandardVO = (BrandStandardVO) serializable;
        }
    }
    return brandStandardVO;
}
```

# 1月11日：

### 1.关于字符串转为char[]

```java
char[] chars = num.toCharArray();
```

### 2.HTML是解释性语言，非编译型

所以在编写HTML代码时，只要错误不是特别明显，都不会出现错误，但可能会导致浏览器无法正常渲染，浏览器也是容错的！

### 3.如何删除数组中的元素：

**第一种方式：替换缩容法**：

> 将需要删除的元素替换为最后一个元素，最后进行缩容处理(若删除的不是最后一个元素，原本删除的元素会替换为原本的最后一个元素)

```java
public class Demo {
    public static void main(String[] args) {
        int[] arr = {1, 2, 3, 4, 5, 6, 7, 8};
        System.out.println(Arrays.toString(arr)+"原数组的长度为："+arr.length);
        for (int i = 0; i < arr.length; i++) {
            if (arr[i] == 3) {
                arr[i] = arr[arr.length - 1]; // 将其赋给最后一个元素
                arr = Arrays.copyOf(arr, arr.length - 1);// 缩容
            }
        }
        System.out.println(Arrays.toString(arr)+"现数组的长度为："+arr.length);
        // 原数组：[1, 2, 3, 4, 5, 6, 7, 8]原数组的长度为：8
        // 原数组：[1, 2, 3, 8, 5, 6, 7]现数组的长度为：7
    }
}
```

**第二种方式：下标复制法**：

```java
public class Demo {
    public static void main(String[] args) {
        int[] nums = {1,2,3,4,5,6,7,8};
        int index = 3;
        System.out.println("原数组：" + Arrays.toString(nums) + "原数组的长度为：" + nums.length);
        int[] newArray = new int[nums.length - 1];// 定义一个新数组，长度为删除后的数组
        for (int i = 0; i < newArray.length; i++) {
            if (index < 0 || index >= nums.length) {
                throw new RuntimeException("元素越界...");
            }
            if (i < index) { // 如果当前i在要删除的元素下标之前，则直接赋值
                newArray[i] = nums[i];
            } else { // 如果在要删除的元素下标之后，对应的值向后一位
                newArray[i] = nums[i + 1];
            }
        }
        System.out.println("现数组：" + Arrays.toString(newArray) + "现数组的长度为：" + newArray.length);
        // 原数组：[1, 2, 3, 4, 5, 6, 7, 8]原数组的长度为：8
        // 现数组：[1, 2, 3, 5, 6, 7, 8]现数组的长度为：7
    }
}
```

**第三种方式：集合API-remove()删除法(或者迭代)**：

> 需要注意两个问题：
>
> 1.基本类型数组->包装类型数组
>
> 2.List<>接口对象不能直接使用remove()或Iterator迭代，需要转成ArrayList<>对象

```java
public class Demo {
    public static void main(String[] args) {
        int[] nums = {1,2,3,4,5,6,7,8};
        int index = 3;
        Integer[] integers = Arrays.stream(nums).boxed().toArray(Integer[]::new);// 先将int[]转换成Integer[]
        List<Integer> l = Arrays.asList(integers); // 将数组转成List集合
        System.out.println("数组删除元素前："+l);
        List<Integer> list = new ArrayList<>(l); // 将List集合转成ArrayList对象，并向上造型
        list.remove(index); // 根据下标删除集合中的元素
        System.out.println("数组删除元素后："+list);
        // 数组删除元素前：[1, 2, 3, 4, 5, 6, 7, 8]
        // 数组删除元素后：[1, 2, 3, 5, 6, 7, 8]
    }
}
```

### 4.int[]数组转Integer[]包装类数组：

在Java 8中，`int[]`可以轻松转换为`Integer[]`：

> 当出现传递int[]数组，但需要使用集合必须传递包装类型的对象时可使用：

```java
public static void main(String[] args) {
    int[] data = {1,2,3,4,5,6,7,8,9,10};

    // To boxed array
    Integer[] what = Arrays.stream( data ).boxed().toArray( Integer[]::new );
    Integer[] ever = IntStream.of( data ).boxed().toArray( Integer[]::new );

    // To boxed list
    List<Integer> you  = Arrays.stream( data ).boxed().collect( Collectors.toList() );
    List<Integer> like = IntStream.of( data ).boxed().collect( Collectors.toList() );
}
```

### 5.迭代器`Iterator`的使用及注意事项：

迭代器是ArrayList对象的方法：

```java
public ListIterator<E> listIterator(final int index) {}
```

应用：

```java
public static void main(String[] args) {
    List<Integer> list = new ArrayList<>();// 将数组转成集合
    list.add(1);
    list.add(2);
    list.add(3);
    list.add(4);
    list.add(5);
    list.add(6);
    list.add(7);
    list.add(8);
    System.out.println("数组删除元素前："+list);
    Iterator<Integer> iterator = list.iterator();
    while (iterator.hasNext()){
        Integer item = iterator.next();
        if (item == num){
            iterator.remove();
            break;
        }
    }
    System.out.println("数组删除元素后："+list);
}
```

特例：

> 当需要将List集合转成ArrayList的对象时：如果不转调用remove()或迭代器Iterator时会出错
>
> 不支持的异常：`UnsupportedOperationException`

```java
public static void main(String[] args) {
    int[] nums = {1,2,3,4,5,6,7,8};
    int index = 3;
    Integer[] integers = Arrays.stream(nums).boxed().toArray(Integer[]::new);// 先将int[]转换成Integer[]
    List<Integer> l = Arrays.asList(integers); // 将数组转成List集合
    System.out.println("数组删除元素前："+l);
    List<Integer> list = new ArrayList<>(l); // 将List集合转成ArrayList对象，并向上造型
    list.remove(index); // 根据下标删除集合中的元素
    System.out.println("数组删除元素后："+list);
}
```

# 1月12日：

### 1.URL没有端口也能访问的问题：

平时百度：http://www.baidu.com 就能访问

因为http默认是80端口，这里百度的端口号肯定也是80端口，默认即可访问！

# 1月13日：

### 1.关于RBAC

RBAC是基于角色的访问控制，通常相关权限管理的项目会使用！

### 2.Druid实时分析型数据库

Druid是一个实时分析型的数据库，用于大规模实时数据导入、快速查询分析的场景，包括网站访问点击流分析、网络性能监控分析、应用性能指标存储与分析、供应链分析、广告分析等

可参考地址：https://zhuanlan.zhihu.com/p/253057898

# 1月14日：

### 1.SDK

SDK是**软件开发工具包**，一般是软件开发工程师为特定的软件包、软件框架、硬件平台、操作系统等建立应用软件时的开发工具的集合。

软件开发工具广义上指**辅助开发某一类软件**的相关文档、范例和工具的集合。

一般而言SDK即开发Windows平台下的应用程序所使用的SDK。它通过编译器、调试器、软件框架等来促进应用程序的创建。它可以简单的为某个[程序设计语言](https://baike.baidu.com/item/程序设计语言/2317999?fromModule=lemma_inlink)提供[应用程序接口](https://baike.baidu.com/item/应用程序接口/10418844?fromModule=lemma_inlink)**[API](https://baike.baidu.com/item/API?fromModule=lemma_inlink)**的一些文件，但也可能包括能与某种[嵌入式系统](https://baike.baidu.com/item/嵌入式系统/186978?fromModule=lemma_inlink)通讯的复杂的硬件。一般的工具包括用于调试和其他用途的实用工具。SDK还经常包括示例代码、支持性的技术注解或者其他的为基本参考资料澄清疑点的支持文档。

# 1月19日：

### 1.关于springboot项目的启动方式

##### 1.执行带有main方法的类:

##### 2.通过`java -jar`的方式:

```sh
java -jar jar_path --param
```

- `param`：指代将项目打包之后的存储路径，例如：

  ```sh
  java -jar emample.jar --server.port=8081
  ```

  > 注：该命令通过在启动行指定了项目启动后绑定的端口号，因为该命令行参数，将会覆盖application.properties中的端口配置

##### 3.通过spring-boot-plugin方式启动:

如果需要正常使用该maven插件，需要我们在maven项目中增加以下插件配置:

```xml
<plugin>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-maven-plugin</artifactId>
    <!--<version>${spring.boot.version}</version>-->
    <!--<executions>-->
        <!--<execution>-->
            <!--<goals>-->
                <!--<goal>repackage</goal>-->
            <!--</goals>-->
        <!--</execution>-->
    <!--</executions>-->
</plugin>
```

> 注：因为我在项目中指定了父模块 spring-boot-starter-parent。因此我不需要单独指定插件版本，该父模块会自动匹配与当前spring-boot版本相匹配的插件版本。

```xml
<parent>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-parent</artifactId>
    <version>1.5.10.RELEASE</version>

    <!--<groupId>com.spring.sourcecode</groupId>-->
    <!--<artifactId>learn.spring</artifactId>-->
    <!--<version>1.0-SNAPSHOT</version>-->
</parent>
```

**准备工作做好之后，我们需要进入项目的根目录，执行**:

```sh
mvn spring-boot:run
```

该命令能够正常启动项目，但是如何为其指定执行参数呢

`spring-boot:run`该maven查件在插件首页中指定了相关能够使用的可选参数：

**通过查阅文档，可以通过命令的方式查看具体选项的意义以及用法**:

```sh
mvn spring-boot:help -Ddetail
```

其中arguments的描述中，大意为：指定的参数会传递给具体应用，如果有多个参数需要指定，以","进行分割。**具体用法通过run.arguments来指定**：

```sh
mvn spring-boot:run -Drun.arguments="--server.port=8888"
```

