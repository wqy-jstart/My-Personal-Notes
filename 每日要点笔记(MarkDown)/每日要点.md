# 8月30日：

#### 1：控制台异常：

![image-20220908161226100](images/image-20220908161226100.png)

#### 2：主动发起连接为客户端

#### 3：Browser/Server，浏览器/服务器模式

#### 4：IP编号：0——65535

#### 5：防火墙：电脑和网络之间的门卫

#### 6：安卓手机底层为Linux系统

#### 7：方法返回什么类型,就用什么类型来接收

#### 8：查询电脑IP：终端——>cmd命令——>ipconfig查询电脑IP

#### 9：IO流与网络传输

![image-20221008150303332](images/image-20221008150303332.png)

#### 10：TCP连接的三次握手和四次挥手

![image-20221008150449854](images/image-20221008150449854.png)

#### 11：IntelliJ IDEA启动程序并列运行

![image-20221008150827799](images/image-20221008150827799.png)

#### 12：通过git命令向远程仓库更新和删除文件

##### 更新：

![image-20220908161946211](images/image-20220908161946211.png)

##### 删除：

![image-20220908162002978](images/image-20220908162002978.png)

# 8月31日：

#### 1：人眼睛观察的极限为30帧

#### 2：线程使用的场合

![image-20221008151000443](images/image-20221008151000443.png)

#### 3：CPU中有逻辑电路和晶体管

#### 4：多核并发,创建并启动线程

![image-20221008151044553](images/image-20221008151044553.png)

![image-20221008152719149](images/image-20221008152719149.png)

#### 5：打桩输出

![image-20220908192052682](images/image-20220908192052682.png)

#### 6:单线程设计

![image-20221008152822466](images/image-20221008152822466.png)

#### 7：run()方法结束,线程声明周期结束，守护线程要等普通线程全部结束后程序结束才能被杀死

#### 8：is开头的方法多半boolean类型

#### 9：内部类的资料

![image-20220908192553375](images/image-20220908192553375.png)

#### 10：集合自定义排序中sort()方法的第二个参数是一个Comparator接口类型,接口不能被实例化,所以创建一个匿名内部类。

![image-20220908192731611](images/image-20220908192731611.png)

# JavaSE的了解：

### Java SE用于开发和部署桌面、服务器以及嵌入设备和实时环境中的Java应用程序，Java SE包括用于开发Java Web服务的类库，同时，Java SE为Java EE提供了基础。

# 9月1日：

#### 1：多个线程同时执行同一块代码称为并发现象

#### 2：线程创建完毕后处于新建状态,调用start()方法后随之执行被重写的run()方法,等待CPU分配完时间片后开始执行

# 9月2日

#### 1：DNS域名解析

![image-20221008152914556](images/image-20221008152914556.png)

![image-20221008152958722](images/image-20221008152958722.png)

#### 2：地址细节处理

![image-20221008153044620](images/image-20221008153044620.png)

#### 3：Git在IDEA中的推送

1：VCS->项目右键->git->add+:

2：VCS->项目右键->git->commit

3：Define remote定义远程

![image-20221008160306618](images/image-20221008160306618.png)

# 9月5日：

#### 1：目录是用来归纳的

#### 2：英文数字符号占一个字节

#### 3：HashSet内部就是HashMap,只是存的时key一列元素

# 9月6日：

#### 1：targer和classes(类加载目录)任意一个类，包的顶层

#### 2:java和resources原代码和资源文件,JVM加载后统一放到classes文件里

![image-20220908201450546](images/image-20220908201450546.png)

#### 3:获取类加载路径

```java
package com.webserver.core
public class ClientHandler{
        public static void main(String[] args) throws URISyntaxException {
        File rootDir = new File( //寻找类加载路径
                ClientHandler.class.getClassLoader()
                        .getResource(".").toURI()
        );
        System.out.println(rootDir);//输出类加载路径
        //定位static目录(static目录下存放的是所有静态资源)
        File staticDir = new File(rootDir,"static");
        System.out.println(staticDir);//输出static目录的全部路径
        //定位static目录下的index.html
        File file = new File(staticDir,"index.html");
        System.out.println("文件是否存在："+file.exists());//true
    }
}
```

![image-20220908201921565](images/image-20220908201921565.png)

#### 4:网页F12打开开发者选项

![image-20220908202101554](images/image-20220908202101554.png)

#### 5:Exception异常的层次

![image-20220909085712587](images/image-20220909085712587.png)

# 9月8日：

#### 1：Debug模式(很实用)

![image-20220908202156486](images/image-20220908202156486.png)

#### 2：内部跳转：当请求路径和看到的页面不同时发生了内部跳转

#### 3：重定向：重定向后页面和路径就会匹配一致

# 9月13日：

#### 1.JDK8新特性lambda、forEach

#### 2：查看一个类的API，按住Ctrl点击类名查看源代码，点击IDEA左侧Project下的Structure可直观呈现所有API

#### 3：ctrl+alt+o删除无用的导包

#### 4：BindException该异常说明有其他程序正在run

#### 5：jar是JAVA的压缩包

![image-20220913160040391](images/image-20220913160040391.png)

## API是预定义的函数：

### ApplicationProgrammingInterface,应用程序编程接口）

#### 是一些预先定义的接口，目的是提供应用程序与开发人员基于某软件或硬件的以访问一组例程的能力，而又无需访问源码，或理解内部工作机制的细节。

# 9月16日：

#### 1：当多种类型数据运算时,会自动向大类型转换

![image-20220916150233334](images/image-20220916150233334.png)

![image-20220916150259918](images/image-20220916150259918.png)

#### 2：当创建对象的时候会自动调用构造方法,一定是先执行超类的静态块再执行派生类的，然后走new的对象的构造方法,若new的派生类或向上造型,则默认先走超类构造方法ABab；若new的超类,则只走超类的静态块和构造方法Aa

![image-20220916160533674](images/image-20220916160533674.png)

#### 3：数据库的重要性：

![image-20221007100956578](images/image-20221007100956578.png)

#### 4：华为云数据库(GaussDB)与MySQL：

#### ![image-20221007101052105](images/image-20221007101052105.png)5：关于华为HUAWEI

![image-20221007101136427](images/image-20221007101136427.png)

# 9月17日：

#### 1：MySQL中的注意语法

##### a:COUNT()：统计某一字段的数量

##### b:DISTINCT关键字：用于去除指定列重复值的行-

##### c:NVL函数： 用来替换NULL值，NVL(arg1,arg2) 当arg1不为null时则函数返回arg1的值,如果arg1为null则返回arg2的值

#### 2：Switch属于分支结构

# 9月18日：

### 枚举型：

```java
enum  DAY
{
      MON = 1 , TUE, WED, THU, FRI, SAT, SUN
};
```

(1) 枚举型是一个集合，集合中的元素(枚举成员)是一些命名的整型常量，元素之间用逗号,隔开。

(2) **DAY**是一个标识符，可以看成这个集合的名字，**是一个可选项**，即是可有可无的项。

(3) 第一个枚举成员的默认值为整型的0，后续枚举成员的值在前一个成员上加1。

(4) 可以人为设定枚举成员的值，从而自定义某个范围内的整数。

(5) 枚举型是预处理指令#define的替代。

(6) 类型定义以分号;结束。

# 9月19：

#### 1：JAVA的jar包网站：https://mvnrepository.com

#### 2：Driver驱动

#### 3：MySQL端口号：3306

# 9月21日：

### 1:

#### GET和POST是HTTP请求的两种基本方法，要说它们的区别，接触过WEB开发的人都能说出一二。

#### 最直观的区别就是GET把参数包含在URL中，POST通过request body传递参数。

#### 你可能自己写过无数个GET和POST请求，或者已经看过很多权威网站总结出的他们的区别，你非常清楚知道什么时候该用什么。

#### 当你在面试中被问到这个问题，你的内心充满了自信和喜悦。

#### 你轻轻松松的给出了一个“标准答案”：

 

- ##### GET在浏览器回退时是无害的，而POST会再次提交请求。

   

- ##### GET产生的URL地址可以被Bookmark，而POST不可以。

   

- ##### GET请求会被浏览器主动cache，而POST不会，除非手动设置。

   

- ##### GET请求只能进行url编码，而POST支持多种编码方式。

   

- ##### GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。

   

- ##### GET请求在URL中传送的参数是有长度限制的，而POST么有。

   

- ##### 对参数的数据类型，GET只接受ASCII字符，而POST没有限制。

   

- ##### GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。

   

- ##### GET参数通过URL传递，POST放在Request body中。

### 2：

### 404、403、400 、408、305等常见错误代码解析

#### （1）.400-请求无效

##### 说明服务器无法理解用户的请求,除非进行修改,不然你按再多刷新也没有用。很可能的情况是,你不小心输入错误了,导致服务器根本不知道你在表达什么。

#### （2）.403-禁止访问

##### 出现403是因为服务器拒绝了你的地址请求,很有可能是你根本就没权限访问网站,就算你提供了身份验证也没有用。很有可能你被禁止访问了。除非你与Web服务器管理员联系,否则一旦遇到403状态码都无法自行解决。

#### （3）.404-无法找到文件

##### 404其实在日常生活中很常见了。代码的意思是找不到要查询的页面。非常有可能是网页被删除了。

#### （4）.405-资源被禁止

##### 资源被禁止,有可能是文件目录权限不够导致的。这时候其实,只要赋予"完全控制"的权限,也是可以解决的

#### （5）.408-请求超时

##### 遇到408意味着你的请求发送到该网站花的时间比该网站的服务器准备等待的时间要长，即链接超时。

#### （6）.305-使用代理

##### 这个代码的意思是，你不能直接访问网站，要通过某个代理才能进去。比如，你想要访问一些外网，一定要使用VPN才可以。

### 3：JavaScript

##### JavaScript一种直译式[脚本语言](https://baike.so.com/doc/2874347-3033293.html)，是一种动态类型、弱类型、基于原型的语言，内置支持类型。它的[解释器](https://baike.so.com/doc/5904938-6117840.html)被称为JavaScript引擎，为[浏览器](https://baike.so.com/doc/2920715-3082096.html)的一部分，广泛用于[客户端](https://baike.so.com/doc/4889711-5107810.html)的脚本语言，最早是在HTML（标准通用标记语言下的一个应用）网页上使用，用来给HTML网页增加动态功能。 

##### 在1995年时，由Netscape公司的[Brendan Eich](https://baike.so.com/doc/1830372-1935746.html)，在[网景导航者](https://baike.so.com/doc/5691991-5904691.html)浏览器上首次设计实现而成。因为Netscape与Sun合作，Netscape管理层希望它外观看起来像[Java](https://baike.so.com/doc/2886868-3046592.html)，因此取名为JavaScript。但实际上它的语法风格与Self及[Scheme](https://baike.so.com/doc/6747345-6961891.html)较为接近。

##### 为了取得技术优势，[微软](https://baike.so.com/doc/2130745-2254356.html)推出了[JScript](https://baike.so.com/doc/5458749-5697138.html)，CEnvi推出ScriptEase，与JavaScript同样可在浏览器上运行。为了统一规格，因为JavaScript[兼容](https://baike.so.com/doc/5731854-10416323.html)于ECMA标准，因此也称为[ECMAScript](https://baike.so.com/doc/6950734-7173135.html)。

### 4：ServLet：

#### （ServletRequest和ServletResponse）接口

**Servlet(Server Applet)，全称Java Servlet，未有中文译文。是用[Java](https://baike.so.com/doc/2886868-3046592.html)编写的服务器端程序。其主要功能在于交互式地浏览和修改数据，生成动态Web内容。狭义的Servlet是指Java语言实现的一个接口，广义的Servlet是指任何实现了这个[Servlet接口](https://baike.so.com/doc/7695074-7969169.html)的类，一般情况下，人们将Servlet理解为后者。**

# 9月22日：

### 一.Map没有继承Collection接口

#### Map和Collection是两个不同的接口,没有继承关系!

![img](images/WV9wXLl.png)

### 二.线程安全：

##### 线程安全不能存NULL值,线程不安全可以存NULL值

#### 1.什么是线程安全?

**线程安全**是多线程编程时的计算机程序代码中的一个概念。在拥有共享数据的多条线程并行执行的程序中，线程安全的代码会通过同步机制保证各个线程都可以正常且正确的执行，不会出现数据污染等意外情况。

#### 2.线程安全的概述

**多个线程**访问同一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他操作，调用这个对象的行为都可以获得正确的结果，那么这个对象就是线程安全的。

或者说:一个类或者程序所提供的接口对于线程来说是[原子操作](https://baike.so.com/doc/6325064-6538672.html)或者多个线程之间的切换不会导致该接口的执行结果存在二义性,也就是说我们不用考虑同步的问题。

线程安全问题大多是由[全局变量](https://baike.so.com/doc/2493130-2634693.html)及[静态变量](https://baike.so.com/doc/1933722-2045776.html)引起的，局部变量逃逸也可能导致线程安全问题。

若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的;若有多个线程同时执行写操作，一般都需要考虑[线程同步](https://baike.so.com/doc/1629469-1722601.html)，否则的话就可能影响线程安全。

#### 3.线程的安全性

**类**要成为线程安全的，首先必须在[单线程](https://baike.so.com/doc/2408393-2546269.html)环境中有正确的行为。如果一个类实现正确(这是说它符合规格说明的另一种方式)，那么没有一种对这个类的对象的操作序列(读或者写公共字段以及调用公共方法)可以让对象处于无效状态，观察到对象处于无效状态、或者违反类的任何不可变量、前置条件或者后置条件的情况。

此外，一个类要[成为](https://baike.so.com/doc/1232463-1303584.html)线程安全的，在被多个线程访问时，不管运行时环境执行这些线程有什么样的时序安排或者交错，它必须仍然有如上所述的正确行为，并且在调用的代码中没有任何额外的同步。其效果就是，在所有线程看来，对于线程安全对象的操作是以固定的、全局一致的顺序发生的。

正确性与[线程安全性](https://baike.so.com/doc/558977-591801.html)之间的关系非常类似于在描述 ACID(原子性、一致性、独立性和持久性)事务时使用的一致性与独立性之间的关系:从特定线程的角度看，由不同线程所执行的对象操作是先后(虽然顺序不定)而不是[并行执行](https://baike.so.com/doc/6555303-6769052.html)的。

#### 4.举例

比如一个 ArrayList 类，在添加一个元素的时候，它可能会有两步来完成:1. 在 Items[Size] 的位置存放此元素;2. 增大 Size 的值。

在[单线程](https://baike.so.com/doc/2408393-2546269.html)运行的情况下，如果 Size = 0，添加一个元素后，此元素在位置 0，而且 Size=1;

而如果是在多线程情况下，比如有两个线程，线程 A 先将元素存放在位置 0。但是此时 CPU 调度线程A暂停，线程 B 得到运行的机会。线程B也向此 ArrayList 添加元素，因为此时 Size 仍然等于 0 (注意哦，我们假设的是添加一个元素是要两个步骤哦，而线程A仅仅完成了步骤1)，所以线程B也将元素存放在位置0。然后线程A和线程B都继续运行，都增加 Size 的值。

那好，我们来看看 ArrayList 的情况，元素实际上只有一个，存放在位置 0，而 Size 却等于 2。这就是"线程不安全"了。

#### 5.线程的安全程度

[线程安全性](https://baike.so.com/doc/558977-591801.html)不是一个非真即假的命题。 Vector 的方法都是同步的，并且 Vector 明确地设计为在多线程环境中工作。但是它的线程安全性是有限制的，即在某些方法之间有状态依赖(类似地，如果在迭代过程中 Vector 被其他线程修改，那么由 Vector.iterator() 返回的 iterator会抛出ConcurrentModificationException)。

对于 Java 类中常见的线程安全性级别，没有一种[分类系统](https://baike.so.com/doc/6618500-6832295.html)可被广泛接受，不过重要的是在编写类时尽量记录下它们的线程安全行为。

Bloch 给出了描述五类线程安全性的分类方法:不可变、线程安全、有条件线程安全、线程兼容和线程对立。只要明确地记录下线程安全特性，那么您是否使用这种系统都没关系。这种系统有其局限性 -- 各类之间的界线不是百分之百地明确，而且有些情况它没照顾到 -- 但是这套系统是一个很好的起点。这种分类系统的核心是调用者是否可以或者必须用外部同步包围操作(或者一系列操作)。下面几节分别描述了[线程安全性](https://baike.so.com/doc/558977-591801.html)的这五种类别。

#### 6.不可变

不可变的对象一定是线程安全的，并且永远也不需要额外的同步 。因为一个不可变的对象只要构建正确，其外部可见状态永远也不会改变，永远也不会看到它处于不一致的状态。Java 类库中大多数基本数值类如 Integer 、 String 和 BigInteger 都是不可变的。

需要注意的是，对于Integer，该类不提供add方法，加法是使用+来直接操作。而+操作是不具线程安全的。这是提供原子操作类AtomicInteger的原因。

#### 7.线程安全

线程安全的对象具有在上面"线程安全"一节中描述的属性 -- 由类的规格说明所规定的约束在对象被多个线程访问时仍然有效，不管运行时环境如何排列，线程都不需要任何额外的同步。这种[线程安全性](https://baike.so.com/doc/558977-591801.html)保证是很严格的 -- 许多类，如 Hashtable 或者 Vector 都不能满足这种严格的定义。

#### 8.有条件的

有条件的线程安全类对于单独的操作可以是线程安全的，但是某些操作序列可能需要外部同步。条件线程安全的最常见的例子是遍历由 Hashtable 或者 Vector 或者返回的[迭代器](https://baike.so.com/doc/4824484-5041154.html) -- 由这些类返回的 fail-fast 迭代器假定在迭代器进行遍历的时候底层集合不会有变化。为了保证其他线程不会在遍历的时候改变集合，进行迭代的线程应该确保它是独占性地访问集合以实现遍历的完整性。通常，独占性的访问是由对锁的同步保证的 -- 并且类的文档应该说明是哪个锁(通常是对象的内部监视器(intrinsic monitor))。

如果对一个有条件线程安全类进行记录，那么您应该不仅要记录它是有条件线程安全的，而且还要记录必须防止哪些操作序列的并发访问。用户可以合理地假设其他操作序列不需要任何额外的同步。

#### 9.线程兼容

线程兼容类不是线程安全的，但是可以通过正确使用同步而在并发环境中安全地使用。这可能意味着用一个 synchronized 块包围每一个方法调用，或者创建一个包装器对象，其中每一个方法都是同步的(就像 Collections.synchronizedList() 一样)。也可能意味着用 synchronized 块包围某些操作序列。为了最大程度地利用线程兼容类，如果所有调用都使用同一个块，那么就不应该要求调用者对该块同步。这样做会使线程兼容的对象作为变量实例包含在其他线程安全的对象中，从而可以利用其所有者对象的同步。

许多常见的类是线程兼容的，如集合类 ArrayList 和 HashMap 、 java.text.SimpleDateFormat 、或者 JDBC 类 Connection 和 ResultSet 。

#### 10.线程对立

线程对立类是那些不管是否调用了外部同步都不能在并发使用时安全地呈现的类。线程对立很少见，当类修改静态数据，而静态数据会影响在其他线程中执行的其他类的行为，这时通常会出现线程对立。线程对立类的一个例子是调用 System.setOut() 的类。

# 10月8日:

### 1.关于Git图片放入同级images文件夹中不显示问题

#### 解决:将图片路径改为相对路径,在图片名前加上images/即可

### 2.Rebuild "static"快捷键ctrl+shift+F9

# 10月9日:

### 1.Spring Initializr中第一个配置Server URL用于方便一些框架资源的下载,从而提高开发效率

### 2.使用正确的框架创建项目,可不需要大量配置文件和引入

### 3.包装类和基本数据类型的区别

- #### 例:int型的默认值为0,但无法判断是否处于默认状态(可以赋值为0)

- #### 例:Integer包装类的默认值为null,相比基本类型多出了一个未赋值的状态,使用较多.

# 10月10日:

### 1.前端元素显示方式包含哪几种

- ##### 通过display样式控制元素的显示方式,方便进行修改

- ##### block: 块级元素的默认值,  特点: 独占一行,可以修改元素宽高, 包括: h1-h6 ,p,div  

- ##### inline: 行内元素的默认值, 特点: 共占一行, 不能修改元素宽高, 包括:span,b,i,s,u,a

- ##### inline-block: 行内块元素的默认值, 特点: 共占一行,可以修改元素宽高, 包括:input ,img  

- ##### none: 隐藏元素 

### 2.同步: 指单线程依次做几件事

### 3.异步: 多线程同时做几件事

### 4.同步请求:

- ##### 指客户端只有一个主线程,"主线程"负责页面渲染和监听操作,如果需要主线程发出请求时,会停止页面渲染(清空页面) 只负责发请求,当服务器响应了数据之后,主线程再次恢复渲染的职责,把服务器响应的数据显示到页面中,这个过程是将页面内容进行了整体的改变,称为整体刷新,同步请求只能实现页面的整体刷新无法实现局部刷新.

- ##### Form表单,浏览器输入地址,超链接都是同步请求(页面整体刷新)

### 5.异步请求:

- ##### 异步请求: 指客户端的主线程负责页面渲染和监听操作,由"子线程"发出请求获取数据,获取到数据后将数据展示到原有页面, 这种就叫做页面的局部刷新, 只有通过异步请求才可以实现.

### 6.失去焦点事件

- ##### 光标离开的一瞬间触发失去焦点事件@blur="f()"

### 7.端口被占用的情况

![image-20221010174222195](images/image-20221010174222195.png)

- 解决方案:

  - 检查是不是有其他项目正在运行,停止其他项目即可解决

  - 如果没有其他工程在运行仍然占着8080端口:

    - 修改项目端口号,在application.properties添加以下内容

      ![1665305546967](images/1665305546967.png)

    - 重启电脑

    - 找到占用8080端口的进程并杀掉进程

      ![1665305567428](images/1665305567428.png)

### 8.关于使用SpringMVC和MyBatis框架常见的错误

- #### HTTP400错误:该错误通常是在处理同步或异步请求时,表单提交用户输入的信息不符合参数列表中的数据类型,会直接随着客户端主线程发出请求时在页面中报400错误.

  - ##### 若为异步请求,区别是客户端不显示页面(子线程请求不到数据),在浏览器控制台Console会报错isAxiosError.js.

- #### HTTP500错误:该错误通常是处理同步或异步请求时,当服务端压力过大或者该关联的地方未关联时,会报500错误.

  - ##### 所谓关联错误就是在处理当前的业务中,需利用@Mapper接口中的@Insert()、@Delete()、@Update()、@Select()定义未实现的增删改查方法,关联传入的SQL语句进行相应的操作时发生的错误,通常最多的是SQL语句输入错误.

  - ##### 同样,若为同步请求,该错误会随着客户端主线程发出请求时在页面报错,若为异步请求时,处理请求数据的是子线程,发生该错误时,页面空白(请求不到数据),在浏览器控制台进行报错isAxiosError.js,IDEA控制台也会报异常SQLSyntaxErrorException

# 10月11日:

### 1.v-if="变量"和v-show="变量"

- #### 都是可以控制元素是否显示

  - ##### 区别是:v-if=false时会删除元素

  - ##### v-show=false时是隐藏元素,需要频繁切换元素显示隐藏的状态时,使用v-show

### 2.IDAE添加自定义生成内容(敲Tab生成)

![image-20221011141114233](images/image-20221011141114233.png)

## 3.JSON

- ### JavaScript JSON

  - #### JSON 是用于存储和传输数据的格式。

  - #### JSON 通常用于服务端向网页传递数据 

- ### 什么是 JSON?

  - ##### JSON 英文全称 **J**ava**S**cript **O**bject **N**otation

  - ##### JSON 是一种轻量级的数据交换格式。

  - ##### JSON是独立的语言 

  - ##### JSON 易于理解。

- #### JSON是一个轻量级的数据交换格式,也叫作数据封装格式

  - [{"name":"刘德华","age":18},{"name":"张学友","age":20},{"name":"郭富城","age":30}]

  - 当服务器给客户端响应的数据类型为**自定义对象或List集合**时, SpringMVC框架会自动将返回的数据转成JSON格式的字符串, 然后通过网络传输给客户端, 客户端接收到的数据是JSON格式的字符串,Axios框架会自动将JSON格式字符串里的数据转成JavaScript语言中的数组或对象.
  
  - ##### 如果传递的对象为NULL,则JavaScript拿到的会是空字符串.


- ### JSON 语法规则

  - ##### 数据为 键/值 对。

  - ##### 数据由逗号分隔。

    ```java
    "name":"Runoob"
    ```

  - ##### 大括号保存对象

    ```java
    {"name":"Runoob", "url":"www.runoob.com"}
    ```

  - ##### 方括号保存数组

```java
    {"sites":[
    {"name":"Runoob", "url":"www.runoob.com"}, 
    {"name":"Google", "url":"www.google.com"},
    {"name":"Taobao", "url":"www.taobao.com"}
    ]}
```

# 10月12日:

### 1.CSS中border边框样式style属性

- ##### none不设置
- ##### hidden隐藏
- ##### dotted一系列的点
- ##### dashed一系列小线段
- ##### solid一条单一的实心直线
- ##### double两条实心直线

### 2.IDEA可以从磁盘中安装插件

![image-20221012094644594](images/image-20221012094644594.png)

### 3.在IDEA的Database数据库中,有时创建的表未能保存,此时点击Refresh刷新即可.

### 4.Config

- ##### config是显示配置信息命令，它是英文单词configuration的缩写，是“配置”的意思。

- ##### 一般是修改系统配置或设置的，计算机中各类软件及系统都有类似CONFIG的文件，其中主要是系统或各软件的配置参数。 config对象对应于javax.servlet.ServletConfig类，此类位于servlet-api.jar包中。

### 5.选择java类右键->Copy Path...->Copy Reference复制当前类完全路径

# 10月13日:

### 1.自动整理代码快捷键:Ctrl+Alt+l

### 2.MyBatis框架中的trim标签

- ##### mybatis的trim标签一般用于去除sql语句中多余的and关键字，逗号，或者给sql语句前拼接 “where“、“set“以及“values(“ 等前缀，或者添加“)“等后缀，可用于选择性插入、更新、删除或者条件查询等操作。

##### 以下是trim标签中涉及到的属性：

- trim标签:用于去除sql中多余关键字,添加前缀等选择性插入、更新、删除或者条件查询的操作。
- prefix属性用于给sql语句拼接的前缀
- suffix属性用于给sql语句拼接的后缀
- suffixOverrides属性用户去除sql语句中多余的","
- if标签用户在test属性中写判断条件

```xml
<!--动态选择性插入数据:
    INSERT INTO product(title,price,num) VALUES(#{title},#{price},#{num})
    在指定三个不为空的字段,#{变量名}会自动往指定方法的参数列表中获取参数,如果是对象,会自动利用getter获取(底层看不见)
    最后进行选择性插入,未插入的字段会保留原来的值
    -->
    <insert id="dynamicInsert">
        INSERT INTO product
        <trim prefix="(" suffix=")" suffixOverrides=",">
            <if test="title!=null">title,</if>
            <if test="price!=null">price,</if>
            <if test="num!=null">num</if>
        </trim>
        VALUES
        <trim prefix="(" suffix=")" suffixOverrides=",">
            <if test="title!=null">#{title},</if>
            <if test="price!=null">#{price},</if>
            <if test="num!=null">#{num}</if>
        </trim>
    </insert>
```

### 3.配置环境变量,以便在终端搬运数据库

![image-20221013202712588](images/image-20221013202712588.png)

### 当环境变量配置完成之后>

- #### 第一步:在IDEA终端中先敲mysql -uroot -proot进入到数据库中

- #### 在数据库中如果没有这张表就先创建

- #### USE使用数据库

- #### 最后source 上传来的sql文件;例如source bbsdb20221013.sql

- #### 出现一堆Query OK时说明数据库搬运成功

# 10月17日:

### 1.shift+F5浏览器缓存刷新

# 10月18日:

### 1:酷鲨商城项目中的一个问题

- ##### 在updateBanner.html页面中修改轮播图,在进入页面后需要利用created:function(){}方法来通过路径传递的修改前的轮播图url来进行展示,

  - ```javascript
    created:function (){
                //created方法是Vue对象初始化过程中的方法,并没有初始化完成,此时如果需要访问Vue对象中的属               性,可以通过this取代v
                //得到地址栏中从上个页面传递过来的图片路径(这里的this指代Vue对象)
                v.oldUrl = location.search.split("=")[1];
            }
    ```

- ##### 这里如果将路径中传递的路径截取后赋值给v中的oldurl时会报以下错误(不能在初始化之前访问v)

  ![image-20221018094250506](images/image-20221018094250506.png)

  

- ##### ★因此需要赋值给this(当前Vue对象)

  - ```javascript
     created:function (){
                //created方法是Vue对象初始化过程中的方法,并没有初始化完成,此时如果需要访问Vue对象中的属性,可以通过this取代v
                //axios请求后为什么可以使用v?因为发请求是使用的子线程,请求完成后created方法早就执行完Vue对象初始化过程也早就完成,所以可以访问v变量
                //得到地址栏中从上个页面传递过来的图片路径(这里的this指代Vue对象)
                v.oldUrl = location.search.split("=")[1];
            }
    ```

### 2.补充一个CSS样式

- 当遇到文本量过大导致页面显示不美观时:

  - ```Css
    white-space: nowrap;//设置内容不换行
    ```

  - ```css
    text-overflow: ellipsis;//有超出显示范围的文本时显示
    ```

  - #### 效果:

    - ![image-20221018174948074](images/image-20221018174948074.png)

### 3.前端MVVM设计模式:

- MVVM是将实现前端某一个业务的所有代码划分为三部分
- M:Model 模型, 指数据模型 ,数据相关代码
- V: View 视图, 指页面标签相关代码
- VM: ViewModel 视图模型, 视图模型负责将页面中可能发生改变的元素和某个变量,在内存中进行绑定, 并且会不断监听变量的值的改变, 当变量的值发生改变,可以立即从绑定的关系中找到对应的页面元素, 这样就不需要每次遍历查找了, 从而提高了执行效率

### 4.什么是Vue?

#### 此框架是目前前端最流行的一款基于MVVM设计模式的框架,使用此框架可以让程序员更加便捷的使用MVVM设计模式

- VUE框架两种使用方式:

  - 多页面模式: 在html页面中引入vue.js框架文件即可
  - 单页面模式(脚手架模式): 第四个阶段讲

- 引入vue.js框架到页面中的两种方式:

  - 引入本地文件的方式, 需要先将vue.js框架文件下载到自己电脑上 然后引入
  - 引入CDN服务上面的vue.js, 这种只需要有框架的url路径即可

- ```XML
  * Vue对象相当于是MVVM设计模式中的VM视图模型, 负责将页面中可能发生改变的元素和
  * data里面的变量进行绑定, 变量的值是什么页面元素就显示什么
  * 而且会不断监听变量值的改变, 值只要一变会立即找到对应的元素并让元素跟着改变
  ```

# 10月19日:

### 1.timestamp时间戳类型当数据发生更改时会自动更新时间为当前时间

- ##### 关闭自动更新时间:

  ```sql
  USE cs;
  ALTER TABLE product
      CHANGE created
          created timestamp NOT NULL default current_timestamp;
  ```

- ##### 打开自动更新时间:

  ```sql
  ALTER TABLE product
      CHANGE created
          created timestamp NOT NULL default current_timestamp
              on update current_timestamp;
  ```

### 2.DOS命令:

- #### netstat -an查看电脑地址状态

- #### systeminfo查看本机信息

### 3.WIN快捷键:

- ##### win+Tab:打开电脑近一个月的使用记录

- ##### win+D键:瞬间切换会桌面

- ##### win+L:给电脑锁屏

- ##### win+E:打卡文件管理

- ##### win+数字键:打开下方由左至右的应用

### 4.后端的三大框架

- 三大框架的作用是提高后端业务代码的开发效率

- SSM:
  - SpringMVC: 从第二个阶段开始接触 到第四阶段  
  - Spring:从第四阶段开始讲  
  - Mybatis: 从第三个阶段开始接触 讲到第四阶段  

### 5.WebServer中的DispatcherServlet类

- ##### 这个类是SpringMVC框架与Tomcat容器整合的一个关键类,接管了处理请求的工作

- ##### 这样当Tomcat将请求对象和响应对象创建完毕后处理请求的环节通过调用这个类来完成,从而将处理请求交给了SpringMVC框架,并在处理后发送响应给浏览器

# 10月20日

#### 1.External Libraries是Java的一个扩展类库,在创建项目,勾选引用时会自动在Maven配置中导入一些对应所需的jar包

- ##### jar包中会包含对应封装过的包和类以及接口以供程序员使用

- ![image-20221020100214430](images/image-20221020100214430.png)

### 2.★过滤器

- #### 创建过滤器

  ![960126cdb423f779dd9e5667ac86689](images/960126cdb423f779dd9e5667ac86689.jpg)

- #### 作用: 可以让客户群请求到服务器资源之前或之后经过过滤器

![1666230312652](images/1666230312652.png)

- #### 如何使用过滤器?

  - 创建Filter类文件		
  - 在WebFilter注解中配置处理的请求路径
  - 在doFilter方法中处理请求,写上判断代码,条件满足执行chain.doFilter(request, response);代码代表放行.
  - 在XXXXApplication.java文件中添加@ServletComponentScan注解 进行过滤器扫描

- #### 过滤器urlParttens配置方式:

  - ##### 精确匹配:   /admin.html  /insertProduct.html  

  - ##### 后缀匹配:  *.jpg     *.html      *.xxx

  - ##### 路径匹配:  /product/*       /user/*   

  - ##### 全部匹配: /*   (匹配网站中所有资源 )

# 10月21日

### 1.数据库三范式

- 以表格为存储方式为关系型数据库
- 以键值对或内存为存储方式为非关系型数据库

# 10月24日

### 1.国外服务器访问速度慢,因为距离较远,因此需要配置为国内服务器,例如:华为云,阿里云

### 2.VarChar(10)指定长度后还会额外使用一个字节去识别你存的内容长度

### 3.Char(10)会直接读取10个长度,不够补空格

### 4.Java包名会体现在源代码上

### 5.Version版本号:X.X.XX(大版本号.小版本号.修正版本Bug)

### 6.数据库

- ##### 数据库中tinyint(byte)

- #### unsigned关键字表示无符号位

  - ##### 效果:tinyint  [-128,127]  ->  [0,255]

- ##### COMMENT用于解释说明字段的意思

- ##### DEFAULT默认值

![image-20221024143234591](images/image-20221024143234591.png)

### 7.项目中含有Test包中含有测试类,用于加载当前环境和依赖文件是否正确

```java
package cn.tedu.csmallproduct;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class CsmallProductApplicationTests {

    @Test
    void contextLoads() {
        System.out.println("Hello World!");
    }
}
```

### 8.MyBatis是处理数据库的一款持久层框架,

- ##### Mybatis整合Spring Boot的依赖项版本号不能不写

### 9.一些可能遇见的错误

- ##### java.lang.IllegalStateException: Failed to load ApplicationContext运行环境错误

#### 报错时冷静处理,分析异常说明:

- ##### 关键看Caused by(引起的原因)----------往往最后一行Caused by是引发的原因

- ![image-20221024153400776](images/image-20221024153400776.png)
