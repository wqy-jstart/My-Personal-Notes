# Java并发-理论基础

## 带着问题去理解

- 多线程的出现主要解决什么问题？
- 多线程不安全是指什么？举例说明。
- 并发出现线程不安全的本质是什么？可见性、原子性、有序性。
- Java是怎么解决并发问题的，3个关键字（JMM、8个Happens-Before）
- 线程安全是不是非真即假？不是
- 线程安全有哪些实现思路？
- 如何理解并发和并行的区别？

## 为什么需要多线程？

众所周知，**CPU、内存、I/O设备的速度是有极大差异的**，为了合理的利用CPU的高性能，平衡这三者的速度差异，计算机体系结构、操作系统、编译程序都做出了贡献，主要体现为：

- <u>CPU增加了缓存，以均衡与内存的速度差异</u>；***导致可见性问题！***

- <u>操作系统增加了进程、线程，以分时复用CPU，进而均衡CPU与I/O设备的速度差异</u>；***导致原子性问题！***

- <u>编译程序优化指令执行次序，使得缓存能够得到更加合理地利用</u>；***导致有序性问题***

## 线程不安全的示例

如果多个线程对同一个共享数据进行访问而不采取同步操作的话，那么操作的结果是不一致的。

以下代码演示了 1000 个线程同时对 cnt 执行自增操作，操作结束之后它的值有可能小于 1000。

```java
public class ThreadUnsafeExample {

    private int cnt = 0;
	// 增加成员变量的值
    public void add() {
        cnt++;
    }
	// 获取当前成员变量的值
    public int get() {
        return cnt;
    }
}
```

// 并发执行：

```java
public static void main(String[] args) throws InterruptedException {
    final int threadSize = 1000;
    // 创建对象
    ThreadUnsafeExample example = new ThreadUnsafeExample();
    // 指定一个线程数量
    final CountDownLatch countDownLatch = new CountDownLatch(threadSize);
    // 创建一个线程池执行器
    ExecutorService executorService = Executors.newCachedThreadPool();
    // 循环执行线程，共同增加cnt变量的值
    for (int i = 0; i < threadSize; i++) {
        executorService.execute(() -> {
            example.add();
            countDownLatch.countDown();
        });
    }
    countDownLatch.await();
    executorService.shutdown();
    System.out.println(example.get());// 990 结果总是小于1000
}
```

## 并发出现问题的根源：并发三要素

### 1.可见性：CPU缓存引起

<u>可见性：一个线程对共享变量的修改，另外一个线程能够立刻看到。</u>

代码示例：

```java
//线程1执行的代码
int i = 0;
i = 10;
//线程2执行的代码
j = i;
```

当线程1执行 i =10这句时，会先把i的初始值加载到CPU1的高速缓存中，然后赋值为10，那么在CPU1的高速缓存当中i的值变为10了，却没有立即写入到主存当中。

此时线程2执行 j = i，它会先去主存读取i的值并加载到CPU2的缓存当中，注意此时内存当中i的值还是0，那么就会使得j的值为0，而不是10.

**这就是可见性问题，线程1对变量i修改了之后，线程2没有立即看到线程1修改的值。**

### 2.原子性：分时复用引起

<u>原子性：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。</u>

代码示例：

```java
int i = 1;
// 线程1执行
i += 1;
// 线程2执行
i += 1;
```

这里需要注意：`i+=1`,需要三条CPU指令

1. 将变量i从内存读取到CPU寄存器；
2. 在CPU寄存器中执行i+1操作；
3. 将最后的结果i写入主内存(缓存机制导致可能写入的是CPU缓存而不是内存)

由于CPU分时复用（线程切换）的存在，<u>线程1执行了第一条指令后，就切换到线程2执行，假如线程2执行了这三条指令后，再切换会线程1执行后续两条指令，将造成最后写到内存中的i值是2而不是3。</u>

### 3.有序性：指令重排引起

<u>有序性：即程序执行的顺序按照代码的先后顺序执行。</u>

代码示例：

```java
int i = 0;
boolean flag = false;
i = 1;                // 语句1
flag = true;          // 语句2
```

从代码顺序上看，语句1是在语句2前面的，那么JVM在真正执行这段代码的时候会保证语句1一定会在语句2前面执行吗? 不一定，为什么呢? 这里可能会发生指令重排序（Instruction Reorder）。

**在执行程序时为了提高性能，编译器和处理器常常会对指令做重排序**。重排序分三种类型：

- 编译器优化的重排序：编译器在不改变单线程程序语义的前提下，可以重新安排程序执行的顺序。
- 指令级的重排序：将多条指令重叠执行，如果不存在数据依赖，处理器可改变执行顺序。
- 内存系统的重排序：处理器使用缓存和读/写缓冲区，这使得加载和存储操作看似可能在乱序执行。

**从 java 源代码到最终实际执行的指令序列，会分别经历下面三种重排序**：

![img](https://pdai.tech/images/jvm/java-jmm-3.png)

这些重排序都可能会导致多线程程序出现内存可见性问题。对于编译器，JMM 的编译器重排序规则会禁止特定类型的编译器重排序（不是所有的编译器重排序都要禁止）。对于处理器重排序，JMM 的处理器重排序规则会要求 java 编译器在生成指令序列时，插入特定类型的内存屏障（memory barriers，intel 称之为 memory fence）指令，通过内存屏障指令来禁止特定类型的处理器重排序（不是所有的处理器重排序都要禁止）。