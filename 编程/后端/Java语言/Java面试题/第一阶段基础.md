# 第一阶段基础

### 1.简述static和final的用法

static: 修饰属性,方法,代码块

1. 静态属性:也可以叫类变量,使用"类名.属性名"来访问

   共有的类变量与对象无关,只和类有关

   注意:类中的实例变量是在创建对象时被初始化的,被 static 修饰的属性，也就是类变量，是在类加载时被创建并进行初始化，类加载的过程是进行一次。也就是类变量只会被创 建一次。 

2. 静态方法："类名.方法名" 直接访问

   注意：static 修饰的方法，不能直接访问本类中的非静态(static)成员(包括方法和属性) 

   本类的非静态方法可以访问本类的静态成员（包括方法和属性），可以调用静态方法。 

final：修饰变量，类，方法 

1. 修饰变量

   被final修饰的成员变量就是常量(常量名大写),一旦赋值就不能被改变

   修饰局部变量:修饰基本数据类型 -> 变量的值不能改变

   修饰引用 -> 引用只能指向固定的对象

   修饰实例变量:默认值不生效,可以再赋值

2. 修饰方法:不能被子类覆盖

3. 修饰类:不能被继承

> 在一个final类中的所有方法,默认都是final的
>
> 注意:final,不可用来修饰构造方法.

### 2.冒泡排序的算法

```java
for(int i = 0; i<arr.length-1; i++){// 控制轮数
    for(int j = 0; j<arr.length-1-i; j++){// 控制每一轮的次数
        if(arr[j]>arr[i+1]){// 每次都是和它下一个元素比
            int t = arr[j];
            arr[j]=arr[j+1];
            arr[j+1]=t;
        }
    }
}
```

### 3.abstract class 和 interface有什么区别?

|          | abstract class                                               | interface                                                    |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 实例化   | 不能                                                         | 不能                                                         |
| 类       | 一种继承关系,一个类只能使用一次继承关系,可以通过实现多个接口 | 一个类可以实现多个interface                                  |
| 数据成员 | 可以有自己的                                                 | 静态的不能被修改的即必须static final,一般不在此定义          |
| 方法     | 可以私有,非abstract方法,必须实现                             | 不能私有,默认是public,abstract类型                           |
| 变量     | 可以私有,变量有默认类型,其值可以在子类中重新定义,也可以重新赋值 | 不可有私有的,默认public static final类型,且必须给初始值,实现类中不能重新定义,不可改变 |
| 设计理念 | 表示的是"is - a"的关系                                       | 表示的是"like - a"的关系                                     |
| 实现     | 需要继承,要用extends                                         | 要用implements                                               |

### 4.类有哪三个基本特性?各特性的特点?

> #### 封装,继承,多态

封装性:

类的封装性为类的成员提供公有、缺省、保护和私有等访问权限，目的是隐藏类中 

的私有变量和类中方法的实现细节。

继承性：

允许通过继承原有类的某些特性或全部特性而产生全新的类，原有的类称为父类， 

产生的新类称为子类。子类不仅可以直接继承父类的共性，而且也可以创建它特有的个性。 

多态性：

是指在基类中定义的属性和方法被子类继承之后，可以具有不同的数据类型或表现 

出不同行为，多态性有两种表现形式：重载和覆盖。

### 5. **Error 和 Exception 有什么区别? 列出你见过的 Exception** 

答：

error 表示系统级的错误和程序不必处理的异常， 是恢复不是不可能但很困难的情况下的一种严重问题； 比如内存溢出，不可能指望程序能处理这样的情况； 

Exception 表示需要捕捉或者需要程序进行处理的异常， 

是一种设计或实现问题；也就是说，它表示如果程序运行正常， 

从不会发生的情况。 

常见异常有： NullPointerException： 

当操作一个空引用时会出现此错误。 NumberFormatException： 

数据格式转换出现问题时出现此异常。 ClassCastException： 

强制类型转换类型不匹配时出现此异常。 ArrayIndexOutOfBoundsException： 

数组下标越界，当使用一个不存在的数组下标时出现此异常。

### 6.java中的内存泄漏

内存泄露是指系统中存在无法回收的内存， 

有时候会造成内存不足或系统崩溃。Java 存在内存泄露。 

Java 中的内存泄露当然是指：存在无用但是垃圾回收器无法回收的对象。 

而且即使有内存泄露问题存在，也不一定会表现出来。 

自己实现堆栈的数据结构时有可能会出现内存泄露。 

### 7.多线程有几种实现方法,都是什么?同步有几种实现方法,都是什么?

答：多线程有四种实现方法：继承 Thread 类或者实现 Runnable 接口,callable接口,线程池 

实现同步也有两种方法：一种是同步方法，另一种是同步代码块。同步方法是在方法返回类型前面加上 synchronized 关键字 

同步代码块是 synchronized (这里写需要同步的对象){...} 

### 8.sleep()和wait()有什么区别?

1.Thread 类的方法：sleep(),yield()等 

Object 的方法：wait()和 notify()等 

2.每个对象都有一个锁来控制同步访问。Synchronized 关键字可以和对象的锁交互，来 

实现线程的同步。 

sleep 方法没有释放锁， 

wait 方法释放了锁，使得其他线程可以使用同步控制块或者方法。 

3.wait，notify 和 notifyAll 只能在同步控制方法或者同步控制块里面使用，而 sleep 可 

以在任何地方使用 

sleep 必须捕获异常，而 wait，notify 和 notifyAll 不需要捕获异常

### 9.java中IO流分为几种?

按功能来分：输入流（input）、输出流（output）。

按类型来分：字节流和字符流。

字节流和字符流的区别是：字节流按 8 位传输以字节为单位输入输出数据，字符流按 16 位传输以字符为单位输入输出数据。

### 10.BIO, NIO, AIO有什么区别?

BIO: Block IO 同步阻塞式IO,就是我们平常使用的传统IO,它的特点是模式简单使用方便,并发处理能力低

NIO: New IO 同步非阻塞 IO，是传统 IO 的升级，客户端和服务器端通过 Channel（通道）通讯，实现了多路复用。

AIO：Asynchronous IO 是 NIO 的升级，也叫 NIO2，实现了异步非堵塞 IO ，异步 IO 的操作基于事件和回调机制。

### 11.Files的常用方法都有哪些?

Files.exists():检查文件路径是否存在

Files. createFile()：创建文件。

Files. createDirectory()：创建文件夹。

Files. delete()：删除一个文件或目录。

Files. copy()：复制文件。

Files. move()：移动文件。

Files. size()：查看文件个数。

Files. read()：读取文件。

Files. write()：写入文件。

### 12.谈谈java与其他语言相比,优点?

Java是一种可以撰写跨平台应用程序的面向对象的程序设计语言

Java具有卓越的通用性,高效性,平台移植性和安全性,广泛应用于PC,数据中心,游戏控制台,科学超级计算机,移动电话和互联网,同时拥有全球最大的开发者专业社群

Java是功能完善且通用的程序设计语言,可以用来开发可靠的,要求严格的应用程序

Java是纯面向对象开发,功能强大,分支众多,没有java不能做的软件,C/S,B/S,从功能上讲,没有语言可以和java比

C是面向过程的,这样往往会导致所谓的单一程序,即所有的功能只包含在几个(通常是一个)代码块中

当然,C语言也有自身的不足,比如:语法不严格,变量类型约束不严格,影响程序的安全性,对数组下标越界不做检查等,从应用角度,C语言较难掌握

### 13.谈谈对面向对象的理解

**面向对象是一种程序设计思想，核心通过以对象为抽象的程序单元，将对象以类为模板，利用属性、方法描绘该对象**。

面向对象三大特征：封装、继承、多态

#### 1.封装：

将属性和方法通过访问控制包装在一个类中，外部通过实例化并调用公开的方法来实现功能。

隐藏内部的实现细节，只保留对外接口。

**优点**：

- 减少耦合
- 减轻维护负担
- 调节性能
- 提高可用性

#### 2.继承：

继承实现IS-A的关系，通过子类继承父类，来获得父类的非私有的属性和方法。

**优点**：

- 高扩展

#### 3.多态：

多态分为：编译时多态和运行时多态

1. 编译时多态指方法重载
2. 运行时多态指程序中定义的对象引用指向具体类型在运行期才确定

**运行时多态有三个条件**：

- 继承：通过继承使多个对象产生可引用关系
- 重写：通过重写实现多种不同状态
- 向上转型：通过向上转型以统一的引用类型指向多个对象的不同实现

### 14.java的跨平台原理

java源程序(.java文件)通过编译器变为.class文件(字节码文件),而它的class文件是基于字节码(以byte为单位存储的文件)的,而字节码文件是描述程序要运行的虚拟指令的集合,这些虚拟指令的集合与任何平台无关,Java虚拟机认识它,即只需在不同的平台部署相应的jre,运行jvm即可!

### 15.有了基本数据类型,为何还要包装类?

Java 是一个面相对象的编程语言，基本类型并不具有对象的性质，为了让基 本类型也具有对象的特征，就出现了包装类型（如我们在使用集合类型 Collection 时就一 定要使用包装类型而非基本类型），它相当于将基本类型“包装起来”，使得它具有了对象 的性质，并且为其添加了属性和方法，丰富了基本类型的操作。 

另外，当需要往 ArrayList，HashMap 中放东西时，像 int，double 这种基本类型是放不进 去的，因为容器都是装 object 的，这是就需要这些基本类型的包装器类了。

### 16.关于"=="和equals()的区别?

"=="操作符专门用来比较两个变量的值是否相等,因为java是值传递,对此其比较的是变量所对应的内存中存储的数值是否相同,要比较两个基本数据类型的数据或两个引用变量是否相等,可以使用==操作

equals()是javaObject定义的方法,用于比较两个独立对象的内容是否相同,好比比较两个人的长相,如果未重写该方法,其与"=="相同,比较内存中的地址,若重写了该方法,比较的就是对象的属性值,包装类型在[-128,127]之间比较的是字面值

### 17.如何将字符串反转?

使用 StringBuilder 或者 stringBuffer 的 reverse() 方法。

```java
// StringBuffer reverse
StringBuffer stringBuffer = new StringBuffer();
stringBuffer. append("abcdefg");
System. out. println(stringBuffer. reverse()); // gfedcba
// StringBuilder reverse
StringBuilder stringBuilder = new StringBuilder();
stringBuilder. append("abcdefg");
System. out. println(stringBuilder. reverse()); // gfedcba
```

### 18.关于java中的集合

> #### Set集合(不可重复), List集合(双向链表), Map集合(键值对映射)

区别HashMap只有key和value值对应,Set可以自动清除相同的元素

List是其对象以线性方式存储,没有特定顺序,每个值都有前后Node节点,较为适合增删元素

### 19.ArrayList和LinkedList的区别?

ArrayList内部是以数组的形式实现的,其实现了基于动态数组的数据结构,Linked基于链表的数据结构

对于随机访问,ArrayList由于LinkedList,因为LinkedList需要移动指针

对于新增和删除操作add和remove

LinkedList占优势,因为ArrayList需要移动数据

### 20.ArrayList和Vector的区别?

线程安全:Vector使用了Syschronized来实现线程同步,是线程安全的,而ArrayList是非线程安全的

性能:ArrayList在性能方面优于Vector,在查询元素是ArrayList快

扩容:ArratList和Vector都会根据实际的需要动态的调整容量,只不过在Vector扩容会增加1倍,而ArrayList会增加50%

### 21.Java的八种基本数据类型

1.boolean ---1字节 2^8-1
2.char ---2字节 2^16-1
3.byte ---1字节  2^8-1
4.short ---2字节 2^16-1
5.int ---4字节 2^32-1
6.long ---8字节 2^64-1
7.float ---4字节 2^32-1
8.double ---8字节 2^64-1

### 22.String、StringBuffer、Stringbuilder

1. String对象是“不可变”的，每次使用，都会在内存中开辟新的空间
2. StringBuffer是线程安全的，起初就会创建一个大的char数组，默认16，可以任意，自动扩容机制
3. StringBuilder不是线程安全的，后面和StringBuffer一样

### 23.final关键字

1. 修饰类：不能被继承，如：String
2. 修饰方法：不能被重写
3. 修饰变量：
   1. 基本变量：值不能变
   2. 引用变量：引用不变，不能引用其他变量，但是被引用的对象可以修改

### 24.static关键字

1. 修饰变量：静态变量，属于类，可以直接类名调
2. 修饰方法：和类一同加载，不依赖任何实例，方法必须有实现
3. 修饰代码块：在类初始化时只加载一次
4. 静态内部类：非静态内部类依赖外部实例，需要有外部实例才行，静态内部类可以直接存在

### 25.类加载顺序

1. 加载父类的静态属性和静态块
2. 加载子类的静态属性和静态块
3. 加载父类的普通属性和代码块
4. 加载父类构造super()
5. 加载子类中普通属性和代码块
6. 加载子类构造方法

### 26.成员变量和局部变量

从语法形式上看：

1. 成员变量是属于类的，局部变量是在代码块或方法中定义的
2. 成员变量可以添加访问控制以及static，局部变量不能
3. 都能被final修饰

生命周期：

成员变量跟随类

局部变量跟随方法

### 27.抽象类和接口的区别

抽象类中可以有普通方法，必须有抽象方法，可以有成员变量，但不能被实例化

接口中只能有抽象方法，可以有静态变量，不能被实例化

### 28.反射

反射使得java成为准动态语言！

1. A类 -> A.class字节码文件 -> 加载到JVM后的字节码对象
2. A的Class对象 -> A的实例
3. 每个类，无论创建多少实例，在JVM中只对应一个Class对象（类被不同的类加载器加载除外）

Java反射的原理就是获取Class对象然后使用java.lang.reflect包提供的方法操作Class对象

java.lang.reflect包对应三个类：

Field：可以用get()和set()方法读取和修改field对象关联的字段

Method：可以使用invoke()方法调用Method对象关联方法

Constructor：可以用Constructor的newInstance()实例化对象

### 29.i++和++i的区别

运算时都能将变量值加一

作为表达式使用的时候，其表达式值不同

1. i++后加1，表达式返回原有i的值
2. ++i先加1，表达式返回增加1的值

### 30.|和||区别

- ||是短路或运算，左侧表达式为true时，就不再计算右侧表达式的值，直接返回结果
- |是非短路逻辑运算，两侧都运算，然后再得到结果（可能会影响性能）
- |也是2进制按位或运算

### 31.final、finally、finalied区别

1. final修饰符：
   - 类不能被继承
   - 方法不能被重写
   - 属性不能被修改
2. finally
   - 异常处理时的finally代码块，不管有没有异常被抛出、捕获、finally代码块都会被执行
3. finalize
   - 方法名，定义在Object类中，被所有类继承，该方法在垃圾收集器删除对象之前调用
